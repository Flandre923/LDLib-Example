

```java

@Mixin(BlockEntity.class) // 目标对象：所有的方块实体。这意味着这个 Mixin 会影响游戏内所有的方块。
public abstract class BlockEntityMixin {
    
    // --- 影子字段 ---
    @Shadow // 声明这个方法存在于目标类 中，允许 Mixin 调用它
    @Nullable // 标记返回值可能为空
    public abstract Level getLevel(); // 引用原版的 getLevel() 方法，用于获取当前方块所在的关卡/世界

    // --- 1. 数据同步 ---
    // 注入点：在 getUpdateTag 方法返回时执行。
    // 原版逻辑：getUpdateTag 用于发送方块实体初次渲染所需的初始数据给客户端。
    @Inject(method = "getUpdateTag", at = @At(value = "RETURN"))
    private void injectGetUpdateTag(HolderLookup.Provider provider, CallbackInfoReturnable<CompoundTag> cir) {
        // 检查当前方块实体是否实现了“同步托管接口”
        if (this instanceof ISyncMangedHolder syncMangedHolder) {
            // 获取原版已经构建好的 NBT 标签（cir.getReturnValue()），我们将在其基础上追加数据
            var tag = cir.getReturnValue();
            // 将序列化后的初始同步数据放入特定的 Key 中，键值由 syncMangedHolder 定义
            tag.put(syncMangedHolder.getSyncTag(), syncMangedHolder.serializeInitialData(provider));
        }
    }

    // --- 2. 存档保存 ---
    // 注入点：在 saveAdditional 方法返回时执行。
    // 原版逻辑：saveAdditional 是方块实体保存额外自定义数据到存档的地方。
    @Inject(method = "saveAdditional", at = @At(value = "RETURN"))
    private void injectSaveAdditional(CompoundTag pTag, HolderLookup.Provider provider, CallbackInfo ci) {
        // 检查是否实现了“持久化托管接口”
        if (this instanceof IPersistManagedHolder persistManagedHolder) {
            // 调用托管系统的保存方法。false 表示这不是掉落物保存，而是正常的存档保存
            persistManagedHolder.saveManagedPersistentData(provider, pTag, false);
        }
    }

    // --- 3. 存档加载 ---
    // 注入点：在 loadAdditional 方法返回时执行。
    // 原版逻辑：从硬盘读取存档数据并应用到方块实体。
    @Inject(method = "loadAdditional", at = @At(value = "RETURN"))
    private void injectLoad(CompoundTag pTag, HolderLookup.Provider provider, CallbackInfo ci) {
        // 优先级判断：
        // 1. 如果是同步数据（带有同步标记），则直接反序列化同步数据（例如客户端刚收到数据包）
        if (this instanceof ISyncMangedHolder syncMangedHolder && pTag.get(syncMangedHolder.getSyncTag()) instanceof CompoundTag tag) {
            syncMangedHolder.deserializeInitialData(provider, tag);
        } 
        // 2. 否则，如果是持久化数据（存档读取），则加载托管数据
        else if (this instanceof IPersistManagedHolder persistManagedHolder) {
            persistManagedHolder.loadManagedPersistentData(provider, pTag);
        }
    }

    // --- 4. 卸载逻辑 ---
    // 注入点：setRemoved 方法返回时。当方块被破坏或区块卸载时调用。
    @Inject(method = "setRemoved", at = @At(value = "RETURN"))
    private void injectSetRemoved(CallbackInfo ci) {
        // 检查是否支持异步 RPC（远程过程调用）逻辑且当前在服务端
        if (this instanceof ISyncPersistRPCBlockEntity syncMangedHolder && getLevel() instanceof ServerLevel) {
            // 断开异步任务（例如停止机器的自动计算任务，防止内存泄漏）
            syncMangedHolder.detachAsyncLogic();
        }
    }

    // --- 5. 重置/加载逻辑 ---
    // 注入点：clearRemoved 方法返回时。当方块撤销移除（例如被活塞移动或区块重新加载）时调用。
    @Inject(method = "clearRemoved", at = @At(value = "RETURN"))
    private void injectClearRemoved(CallbackInfo ci) {
        if (this instanceof IManagedHolder managed) {
            // 确保存储容器已经初始化（准备就绪）
            managed.getRootStorage().requireInit();
            // 如果是服务端，重新挂载异步逻辑（恢复机器运转）
            if (managed instanceof ISyncMangedHolder syncMangedHolder && getLevel() instanceof ServerLevel) {
                syncMangedHolder.attachAsyncLogic();
            }
        }
    }
}
```

```java
    default void saveManagedPersistentData(HolderLookup.Provider provider, CompoundTag tag, boolean forDrop) {
    // 1. 从存储根获取所有被标记为“需要持久化”的字段引用列表
    var persistedFields = getRootStorage().getPersistedFields();

    // 2. 创建一个专门用于存放托管数据的子标签，避免污染原版 NBT 的根路径（保持整洁）
    var managedTag = new CompoundTag();

    // 3. 创建序列化上下文。NbtOps.INSTANCE 指定了我们要序列化成 NBT 格式，provider 提供注册表支持
    var ctx = provider.createSerializationContext(NbtOps.INSTANCE);

    // 4. 遍历所有需要持久化的字段
    for (var persistedField : persistedFields) {
        // 5. 过滤逻辑：如果当前是为了生成掉落物，并且该字段配置了“死亡不保留”，则跳过
        if (forDrop && !persistedField.getKey().isDrop()) {
            continue;
        }

        // 6. 利用 Codec (序列化器) 读取字段当前的值并转换为 NBT 元素
        var data = persistedField.readPersisted(ctx);

        // 7. 如果数据不为空，将其写入 managedTag。setTagExtended 支持路径写入（如 "inventory.item"）
        if (data != null) {
            TagUtils.setTagExtended(managedTag, persistedField.getPersistedKey(), data);
        }
    }

    // 8. 处理自定义保存逻辑：允许开发者手动写入一些非自动化的数据
    var customTag = new CompoundTag();
    saveCustomPersistedData(provider, customTag, forDrop);

    // 9. 结构化写入：将托管数据放入主标签的 "managed" 键下
    if (!managedTag.isEmpty()) {
        tag.put("managed", managedTag);
    }

    // 10. 将自定义数据放入托管数据的 "custom" 键下，形成层级结构
    if (!customTag.isEmpty()) {
        managedTag.put("custom", customTag);
    }
}
```

```java
public interface IManagedStorage {
    /** 获取所有受管理的子对象（可能是字段组或嵌套对象） */
    IManaged[] getManaged();

    /** 根据唯一 Key 获取字段的引用对象（Ref）。Ref 是字段的包装器，包含读写逻辑 */
    IRef<?> getFieldByKey(ManagedKey key);

    /** 获取所有非延迟加载的字段。非延迟字段通常在初始化时必须立即加载 */
    IRef<?>[] getNonLazyFields();

    /** 检查是否有任何“同步字段”发生了改变（即脏标记）。
     *  用于判断是否需要向客户端发送数据包 */
    boolean hasDirtySyncFields();

    /** 检查是否有任何“持久化字段”发生了改变。
     *  用于判断是否需要保存到硬盘（虽然存档通常是定期保存，但这可用于优化） */
    boolean hasDirtyPersistedFields();

    /** 获取所有配置为需要保存到硬盘的字段列表 */
    IRef<?>[] getPersistedFields();

    /** 获取所有配置为需要同步给客户端的字段列表 */
    IRef<?>[] getSyncFields();

    /**
     * 为某个字段添加监听器（观察者模式）。
     * 当该字段从服务端同步到客户端更新时，触发回调。
     * 常用于 GUI 自动刷新。
     * @return 返回一个订阅对象，可用于取消监听
     */
    <T> ISubscription addSyncUpdateListener(ManagedKey key, IFieldUpdateListener<T> listener);

    /** 移除指定 Key 的所有监听器 */
    void removeAllSyncUpdateListener(ManagedKey key);

    /** 检查某个 Key 是否注册了监听器（可用于优化，没有监听器时不需同步 UI 数据） */
    boolean hasSyncListener(ManagedKey key);

    /** 通知系统某个字段已更新，并触发所有相关的 Consumer 回调 */
    <T> Stream<Consumer> notifyFieldUpdate(ManagedKey key, T currentValue);

    /**
     * 手动标记某个字段为“脏”。
     * 修改字段值通常不会自动触发网络同步，需要显式调用此方法告诉系统“这个值变了，快发个包给客户端”。
     */
    default void markDirty(ManagedKey key) {
        getFieldByKey(key).markAsDirty();
    }

    /** 标记所有同步字段为脏。用于全量同步（例如玩家刚加入游戏） */
    default void markAllDirty() {
        for (IRef<?> syncField : getSyncFields()) {
            syncField.markAsDirty();
        }
    }

    /**
     * 初始化校验。
     * 应在类加载完成但数据尚未变动前调用，确保存储结构准备就绪。
     * 通常用于检查字段注册是否冲突或完成懒加载初始化。
     */
    void requireInit();
}

```


```java

/**
 * Ref is a reference to a field instance, it's used to detect / manage the field's dirty status.
 * <br>
 * Also, can be used to obtain the internal value.
 */
// Ref 是对字段实例的引用，用于检测和管理字段的“脏状态”（即是否需要更新）。
// 同时，它也可以用来获取内部的真实值。
public interface IRef<TYPE> {
    /**
     * ManagedKey refer to ref's meta info. It's used to get the field's name, type, etc.
     */
    // 获取元数据 Key。ManagedKey 包含了字段的名字、类型等描述信息。
    ManagedKey getKey();

    /**
     * The creator of this ref. please refer to {@link IAccessor#createRef(ManagedKey, Object)}
     * <br>
     * This accessor is not same as the accessor in {@link ManagedKey#getFieldAccessor()}, it's the accessor that created this ref.
     */
    // 获取创建此 Ref 的访问器。
    // 注意：这个 Accessor 负责具体的读写逻辑实现，与 ManagedKey 中的 Accessor 可能不同。
    IAccessor<TYPE> getAccessor();

    /**
     * Read the real value of the field.
     */
    // 直接从内存中读取字段的原始 Java 对象值。
    TYPE readRaw();

    /**
     * Write the real value.
     */
    // 直接将 Java 对象值写入内存字段。
    void writeRaw(TYPE value);

    /**
     * whether the ref is dirty and need to be synced.
     */
    // 检查该字段是否为“同步脏”状态（即是否需要通过网络发送给客户端）。
    boolean isSyncDirty();

    /**
     * whether the ref is dirty and need to be persisted.
     */
    // 检查该字段是否为“持久化脏”状态（即是否需要保存到存档文件）。
    boolean isPersistedDirty();

    /**
     * Clear sync dirty mark. It should be called after the field has been synced.
     */
    // 清除同步脏标记。通常在数据包成功发送后调用。
    void clearSyncDirty();

    /**
     * Clear persisted dirty mark. It should be called after the field has been persisted.
     */
    // 清除持久化脏标记。通常在存档保存完成后调用。
    void clearPersistedDirty();

    /**
     * Mark the ref as dirty, it should be called while the field has been changed.
     */
    // 手动将此字段标记为“脏”。当字段值发生改变时必须调用，否则系统不知道需要同步或保存。
    void markAsDirty();

    /**
     * Called automatically if it is a non-lazy ref.
     * <br>
     * Implement this method to check it has changes (e.g. internal changed, instance change). If it has changed, it should mark as dirty.
     */
    // 如果是非延迟加载的 Ref，系统会自动调用此方法。
    // 实现此方法用于检查内部数据是否发生变化（例如集合内部元素变了，但对象引用没变），如果变了则自动标记为脏。
    void update();

    /**
     * listener should be called while it has changed.
     */
    // 设置同步监听器。当字段因网络同步而改变时，触发此回调。
    void setOnSyncListener(BooleanConsumer listener);

    /**
     * listener should be called while it has changed.
     */
    // 设置持久化监听器。当字段因存档加载/保存而改变时，触发此回调。
    void setOnPersistedListener(BooleanConsumer listener);

    /**
     * set persisted prefix name
     */
    // 获取持久化时的键名前缀（用于处理嵌套 NBT 结构，如 "inventory.item"）。
    @Nullable
    String getPersistedPrefixName();

    /**
     * set persisted prefix name
     */
    // 设置持久化时的键名前缀。
    void setPersistedPrefixName(String name);

    // 获取最终写入 NBT 的完整键名（默认实现）。
    // 逻辑：
    // 1. 优先使用配置的 PersistentKey -> 
    // 2. 其次使用字段名 -> 
    // 3. 如果有前缀则加上 "前缀.键名"。
    default String getPersistedKey() {
        var fieldKey = getKey();
        String key = fieldKey.getPersistentKey();
        if (Strings.isNullOrEmpty(key)) {
            key = fieldKey.getName(); // 回退到字段名
        }
        if (!Strings.isNullOrEmpty(getPersistedPrefixName())) {
            key = getPersistedPrefixName() + "." + key; // 处理层级路径
        }
        return key;
    }

    /** 
     * This method is used to read the persisted data.
     */
    // 持久化读取：利用 DynamicOps（如 NbtOps）将 NBT 数据读取并转换为 Java 对象。
    default <T> T readPersisted(DynamicOps<T> op) {
        return getAccessor().readField(op, this);
    }

    /** 
     * This method is used to write the persisted data.
     */
    // 持久化写入：利用 DynamicOps 将当前 Java 对象转换为 NBT 元素。
    default <T> void writePersisted(DynamicOps<T> op, T payload) {
        getAccessor().writeField(op, this, payload);
    }

    /** 
     * This method is used to read the sync initial data.
     */
    // 初始同步读取：用于玩家进入区块时，获取该方块实体的完整初始数据。
    default <T> T readInitialSync(DynamicOps<T> op) {
        return getAccessor().readField(op, this);
    }

    /**
     * This method is used to write the sync initial data.
     */
    // 初始同步写入：将初始数据写入同步标签。
    default <T> void writeInitialSync(DynamicOps<T> op, T payload) {
        getAccessor().writeField(op, this, payload);
    }

    /** 
     * This method is used to read the sync changed data.
     */
    // 网络流读取：从字节缓冲区读取增量更新数据。
    // 用于 1.21+ 的高性能网络传输。
    default void readSyncToStream(RegistryFriendlyByteBuf buffer) {
        getAccessor().readFieldToStream(buffer, this);
    }

    /**
     * This method is used to write the sync changed data.
     */
    // 网络流写入：将增量更新数据写入字节缓冲区。
    default void writeSyncFromStream(RegistryFriendlyByteBuf buffer) {
        getAccessor().writeFieldFromStream(buffer, this);
    }
}
```


```java
public interface ISyncMangedHolder extends IManagedHolder, IAsyncLogic {

    // --- 抽象定义 ---

    /**
     * 抽象方法：由实现类决定如何创建一个自定义的数据包载体。
     *
     * @param changed 位图，标记了哪些字段发生了变化
     * @param data    序列化后的二进制数据载荷
     * @param extra   额外的 NBT 数据（用于非托管数据的传输）
     */
    CustomPacketPayload createSyncPacket(BitSet changed, byte[] data, CompoundTag extra);

    // --- 同步核心逻辑 ---

    /**
     * 执行同步操作。如果方块实体是可 Tick 的，通常会自动处理。
     *
     * @param force 如果为 true，则强制同步所有字段（常用于玩家初次连接）；
     *              否则仅同步已改变（脏）的字段（增量更新）。
     */
    default void sync(boolean force) {
        // 获取存储该方块实体所有字段的根容器
        var rootStorage = this.getRootStorage();

        // 1. 预扫描：更新所有非延迟加载的字段
        for (var field : rootStorage.getNonLazyFields()) {
            field.update();
            // 解释：调用 update() 会触发字段内部的自我检查机制。
            // 例如，如果字段是一个 List，即便 List 对象引用没变，
            // 但其内部元素数量变化了，update() 方法应将自身标记为“脏”。
        }

        // 2. 快速检查：判断是否存在任何需要同步的字段
        if (rootStorage.hasDirtySyncFields()) {
            var changed = new BitSet(); // 创建一个位图，用于标记哪些索引的字段发生了变化（比传字段名更省流量）
            var syncedFields = rootStorage.getSyncFields(); // 获取所有配置了“需要同步”的字段数组
            var serverLevel = getServerLevel(); // 获取当前服务端层级对象

            // 3. 序列化：将需要同步的字段写入二进制缓冲区
            var data = ByteBufUtil.writeCustomData(buffer -> {
                for (int i = 0; i < syncedFields.length; i++) {
                    var field = syncedFields[i];
                    // 判断逻辑：如果是强制同步 OR 该字段被标记为脏
                    if (force || field.isSyncDirty()) {
                        changed.set(i); // 在位图中记录索引位置 i（BitSet 非常节省空间）
                        field.readSyncToStream(buffer); // 调用字段自身的访问器，将值写入二进制流
                        field.clearSyncDirty(); // 清除该字段的脏标记，表示此变更已处理，避免重复发送
                    }
                }
            }, serverLevel.registryAccess());
            // 注册表访问权限：对于 ItemStack、BlockState 等复杂对象，序列化时需要查表 ID，必须传入此参数

            // 4. 线程安全分发：将任务提交到主线程执行
            serverLevel.getServer().executeIfPossible(() -> {
                // 准备扩展数据：用于存放不属于自动化管理，但仍需同步的额外信息
                var extra = new CompoundTag();
                writeCustomSyncData(extra); // 钩子方法：允许子类写入自定义数据

                // 构建最终的 NMS/NeoForge 数据包对象
                var packet = createSyncPacket(changed, data, extra);

                // 智能分发：仅发送给正在“观察”该方块所在区块的玩家
                // 这是一个极其重要的网络优化，避免了全服广播
                PacketDistributor.sendToPlayersTrackingChunk(getServerLevel(), this.getTrackingPos(), packet);
            });
        }
    }

    // --- 便捷方法 ---

    /**
     * 被动同步
     * 默认调用 sync(false)，即仅同步变化的部分。
     * 通常在 Tick 循环或特定事件触发时调用，以保持数据一致性。
     */
    default void passivelySync() {
        sync(false);
    }
}

```